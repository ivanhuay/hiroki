{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started with hiroki In this tutorial we are going to build our first rest API using hiroki. Some things in this tutorial aren't the best practice but this is to keep the example simpler as possible. Setup First we must create a project folder. mkdir hello-hiroki cd hello-hiroki Now we have to create a packege.json file. npm init -y Install dependencies. npm i --save express mongoose body-parser hiroki Project folders Create a model folder. mkdir models in this folder we have to create our models. Create the first model create a model file (models/book.js) in models folder. models/book.js const mongoose = require('mongoose'); const Book = new mongoose.Schema({ title: String, description: String }); module.exports = mongoose.model('Book', Book); Create a index file for models. models/index.js const Book = require('./book'); module.exports = { Book } The server file Create a file app.js . step by step: Import dependencies: const express = require('express'); const mongoose = require('mongoose'); const models = require('./models'); const bodyParser = require('body-parser'); const hiroki = require('hiroki'); Create the express app and use body-parser. const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); Connect to mongo: mongoose.connect('mongodb://localhost:27017/test') .then(()=>{ console.log('connection succes!'); }) Build the rest api: Object.keys(models).forEach((model)=>{ hiroki.rest(model); }) app.use(hiroki.build()); Handle errors: app.use(function(req, res, next) { let err = new Error('Not Found'); err.status = 404; next(err); }); app.use(function(error, req, res, next) { console.error('handleError: ', error); return res.status(error.status || 500).json({ status: error.status, error: error.message, stack: error.stack }); }); The end: add the app listen app.listen(3030); console.log('server listening on port 3030...'); File app.js: This is the complete file. const express = require('express'); const mongoose = require('mongoose'); const models = require('./models'); const bodyParser = require('body-parser'); const hiroki = require('hiroki'); const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); mongoose.connect('mongodb://localhost:27017/test') .then(()=>{ console.log('connection succes!'); }) Object.keys(models).forEach((model)=>{ hiroki.rest(model); }) app.use(hiroki.build()); app.use(function(req, res, next) { let err = new Error('Not Found'); err.status = 404; next(err); }); app.use(function(error, req, res, next) { console.error('handleError: ', error); return res.status(error.status || 500).json({ status: error.status, error: error.message, stack: error.stack }); }); app.listen(3030); console.log('server listening on port 3030...'); Start application node app.js now you can open http://localhost:3030/api/books . have fun! Remember: GET: get documents. POST: create one document. PUT: update one document. DELETE: remove one document. Source code: HERE","title":"Getting started with hiroki"},{"location":"#getting-started-with-hiroki","text":"In this tutorial we are going to build our first rest API using hiroki. Some things in this tutorial aren't the best practice but this is to keep the example simpler as possible.","title":"Getting started with hiroki"},{"location":"#setup","text":"First we must create a project folder. mkdir hello-hiroki cd hello-hiroki Now we have to create a packege.json file. npm init -y Install dependencies. npm i --save express mongoose body-parser hiroki","title":"Setup"},{"location":"#project-folders","text":"Create a model folder. mkdir models in this folder we have to create our models.","title":"Project folders"},{"location":"#create-the-first-model","text":"create a model file (models/book.js) in models folder. models/book.js const mongoose = require('mongoose'); const Book = new mongoose.Schema({ title: String, description: String }); module.exports = mongoose.model('Book', Book); Create a index file for models. models/index.js const Book = require('./book'); module.exports = { Book }","title":"Create the first model"},{"location":"#the-server-file","text":"Create a file app.js .","title":"The server file"},{"location":"#step-by-step","text":"Import dependencies: const express = require('express'); const mongoose = require('mongoose'); const models = require('./models'); const bodyParser = require('body-parser'); const hiroki = require('hiroki'); Create the express app and use body-parser. const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); Connect to mongo: mongoose.connect('mongodb://localhost:27017/test') .then(()=>{ console.log('connection succes!'); }) Build the rest api: Object.keys(models).forEach((model)=>{ hiroki.rest(model); }) app.use(hiroki.build()); Handle errors: app.use(function(req, res, next) { let err = new Error('Not Found'); err.status = 404; next(err); }); app.use(function(error, req, res, next) { console.error('handleError: ', error); return res.status(error.status || 500).json({ status: error.status, error: error.message, stack: error.stack }); }); The end: add the app listen app.listen(3030); console.log('server listening on port 3030...');","title":"step by step:"},{"location":"#file-appjs","text":"This is the complete file. const express = require('express'); const mongoose = require('mongoose'); const models = require('./models'); const bodyParser = require('body-parser'); const hiroki = require('hiroki'); const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); mongoose.connect('mongodb://localhost:27017/test') .then(()=>{ console.log('connection succes!'); }) Object.keys(models).forEach((model)=>{ hiroki.rest(model); }) app.use(hiroki.build()); app.use(function(req, res, next) { let err = new Error('Not Found'); err.status = 404; next(err); }); app.use(function(error, req, res, next) { console.error('handleError: ', error); return res.status(error.status || 500).json({ status: error.status, error: error.message, stack: error.stack }); }); app.listen(3030); console.log('server listening on port 3030...');","title":"File app.js:"},{"location":"#start-application","text":"node app.js now you can open http://localhost:3030/api/books . have fun!","title":"Start application"},{"location":"#remember","text":"GET: get documents. POST: create one document. PUT: update one document. DELETE: remove one document.","title":"Remember:"},{"location":"#source-code","text":"HERE","title":"Source code:"},{"location":"extending-hiroki/configuration/","text":"Configuration using hiroki.rest you can pass as a second parameter a configuration object. const options = { shareQueryEnabled: false, //Bool fastUpdate: 'enabled', //Enum - options enabled, disabled, optional disabledPluralize: false //Bool }; hiroki.rest(model, options); shareQueryEnabled: enable shared queries route. (more info here)[#share-query] fastUpdate: with enabled UPDATE methods run faster but pre save method of models won't run. There are some posibles values: optional: with optional you have to send a query param ?fast=true enabled: always working. disabled: not working.","title":"Configuration"},{"location":"extending-hiroki/configuration/#configuration","text":"using hiroki.rest you can pass as a second parameter a configuration object. const options = { shareQueryEnabled: false, //Bool fastUpdate: 'enabled', //Enum - options enabled, disabled, optional disabledPluralize: false //Bool }; hiroki.rest(model, options); shareQueryEnabled: enable shared queries route. (more info here)[#share-query] fastUpdate: with enabled UPDATE methods run faster but pre save method of models won't run. There are some posibles values: optional: with optional you have to send a query param ?fast=true enabled: always working. disabled: not working.","title":"Configuration"},{"location":"extending-hiroki/decorators/","text":"Extending Hiroki you can easly extend hiroji using a simple express middleware. Using decorators hiroki.rest return a Controller object. see details of controller methods here . Example ... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); const controller = hiroki.rest('Users'); controller.request('get', (req,res,next) =>{ req.query.limit = 3; //override query params limit next(); }) app.use('/api', hiroki.build()); app.listen(8012);","title":"Extending Hiroki"},{"location":"extending-hiroki/decorators/#extending-hiroki","text":"you can easly extend hiroji using a simple express middleware.","title":"Extending Hiroki"},{"location":"extending-hiroki/decorators/#using-decorators","text":"hiroki.rest return a Controller object. see details of controller methods here .","title":"Using decorators"},{"location":"extending-hiroki/decorators/#example","text":"... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); const controller = hiroki.rest('Users'); controller.request('get', (req,res,next) =>{ req.query.limit = 3; //override query params limit next(); }) app.use('/api', hiroki.build()); app.listen(8012);","title":"Example"},{"location":"extending-hiroki/overview/","text":"Controller Object hiroki.rest return a Controller object. this object build routes for a particular mongoose model. const controller = hiroki.rest(model); Structure Methods request: extend functionality using middlewares before hiroki native middlewares. build: build specific route. (hiroki.build run build for each controller) Statics methods Controller.getRouter: return the current express router. Set properties disabledMethods: String with disabled routes. Ej: disabledMethods = \"get post\"'' outgoing: format middleware before response. beforeEnd: after format route. Details Usage detail of use for some useful functions Request controler.request(methods, middleware) enable to add middleware before hiroki routes. methods(String): methods separated by spaces. get post put delete if you wish you can ignore the methods parameter and the middleware will apply to all methods. Example: ... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); const controller = hiroki.rest('Users'); controller.request((req, res, next) => { //do something //... next(); }); controller.request('delete post put', (req,res,next) =>{ req.status(401).json({error:'unauthorized'}); }) app.use('/api', hiroki.build()); app.listen(8012); Disabled methods DisabledMethods alows you to disable some hiroki methods. request with this methods return 404 status. Example: ... const controller = hiroki.rest('Users'); controller.disabledMethods = 'delete put'; app.use('/api', hiroki.build()); app.listen(8012); Outgoing Outgoing allows you to add a formatting function before the output. The function receives each document and is executed once for each document. ... const controller = hiroki.rest('Users'); controller.outGoing = function(doc) { doc.outName = doc.name.toUpperCase() return doc }; app.use('/api', hiroki.build()); app.listen(8012); BeforeEnd beforeEnd allows you to add a middleware that is executed before returning the server response and after formatting all the documents within this function you can manipulate the object req.rest req.rest can contain up to 3 parameters: count, response (formatted documents) and status (http status) req.rest structure { \"count\": \"Number\", \"response\": \"Docs\", \"status\": \"Number\" } beforeEnd usage controller.beforeEnd = function(req,res,next){ doSomething(); next(); //hiroki make the response }","title":"Controller Object"},{"location":"extending-hiroki/overview/#controller-object","text":"hiroki.rest return a Controller object. this object build routes for a particular mongoose model. const controller = hiroki.rest(model);","title":"Controller Object"},{"location":"extending-hiroki/overview/#structure","text":"","title":"Structure"},{"location":"extending-hiroki/overview/#methods","text":"request: extend functionality using middlewares before hiroki native middlewares. build: build specific route. (hiroki.build run build for each controller)","title":"Methods"},{"location":"extending-hiroki/overview/#statics-methods","text":"Controller.getRouter: return the current express router.","title":"Statics methods"},{"location":"extending-hiroki/overview/#set-properties","text":"disabledMethods: String with disabled routes. Ej: disabledMethods = \"get post\"'' outgoing: format middleware before response. beforeEnd: after format route.","title":"Set properties"},{"location":"extending-hiroki/overview/#details-usage","text":"detail of use for some useful functions","title":"Details Usage"},{"location":"extending-hiroki/overview/#request","text":"controler.request(methods, middleware) enable to add middleware before hiroki routes. methods(String): methods separated by spaces. get post put delete if you wish you can ignore the methods parameter and the middleware will apply to all methods. Example: ... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); const controller = hiroki.rest('Users'); controller.request((req, res, next) => { //do something //... next(); }); controller.request('delete post put', (req,res,next) =>{ req.status(401).json({error:'unauthorized'}); }) app.use('/api', hiroki.build()); app.listen(8012);","title":"Request"},{"location":"extending-hiroki/overview/#disabled-methods","text":"DisabledMethods alows you to disable some hiroki methods. request with this methods return 404 status. Example: ... const controller = hiroki.rest('Users'); controller.disabledMethods = 'delete put'; app.use('/api', hiroki.build()); app.listen(8012);","title":"Disabled methods"},{"location":"extending-hiroki/overview/#outgoing","text":"Outgoing allows you to add a formatting function before the output. The function receives each document and is executed once for each document. ... const controller = hiroki.rest('Users'); controller.outGoing = function(doc) { doc.outName = doc.name.toUpperCase() return doc }; app.use('/api', hiroki.build()); app.listen(8012);","title":"Outgoing"},{"location":"extending-hiroki/overview/#beforeend","text":"beforeEnd allows you to add a middleware that is executed before returning the server response and after formatting all the documents within this function you can manipulate the object req.rest req.rest can contain up to 3 parameters: count, response (formatted documents) and status (http status)","title":"BeforeEnd"},{"location":"extending-hiroki/overview/#reqrest-structure","text":"{ \"count\": \"Number\", \"response\": \"Docs\", \"status\": \"Number\" }","title":"req.rest structure"},{"location":"extending-hiroki/overview/#beforeend-usage","text":"controller.beforeEnd = function(req,res,next){ doSomething(); next(); //hiroki make the response }","title":"beforeEnd usage"},{"location":"rest-api/","text":"Usage, methods & parameters GET get list of resources or a particular resource using filter or ids. Basic request: Basic GET /api/books Response: [ { \"id\":\"5d234073a00ebf1921a9225a\", \"title\":\"Example\", \"createdAt\" : ISODate(\"2019-07-08T13:09:07.346Z\"), \"updatedAt\" : ISODate(\"2019-07-08T18:26:01.800Z\"), }, { \"id\":\"5d234073a00ebf1921a9225b\", \"title\":\"Example 2\", \"createdAt\" : ISODate(\"2019-07-08T13:02:07.346Z\"), \"updatedAt\" : ISODate(\"2019-07-08T18:28:01.800Z\"), }, ... ] By Id GET /api/books/5d234073a00ebf1921a9225a { \"id\":\"5d234073a00ebf1921a9225a\", \"title\":\"Example\", \"createdAt\" : ISODate(\"2019-07-08T13:09:07.346Z\"), \"updatedAt\" : ISODate(\"2019-07-08T18:26:01.800Z\"), } Query filtering: Conditions Conditions paramer is like mongoose find parameter but you always should use the stringified version. Basic Example GET /api/books?conditions={ \"title\": \"Example1\" } Using mongoose $near GET /api/people?conditions={ \"location\": { \"$near\": [44, -97] } } Using mongoose $search GET /api/people?conditions={ \"$text\": { \"$search\": \"dog bites man\" } } Skip Same as mongoose skip GET /api/horses?skip=3 skip the first 3 documents. Limit Same as mongoose limit . GET /api/horses?limit=3 get only 3 documents. Sort Similar to mongoose sort . this example sort by name / decreasing age GET /api/cheeses?sort=name -age Select Similar to mongoose select . It is a string space separated. Also you can use -[String] to not select some field. Basic Example GET /api/phones?select=name Negative select GET /api/phones?select=-_id -year this show all the document except _id & year . Populate Same as mongoose populate. Basic Example: GET /api/boats?populate=captain Using match GET /api/cities?populate={ \"path\": \"captain\", \"match\": { \"age\": \"44\" } } The select option of populated documents is disallowed. Count Same as mongoose count . Basic: GET /api/stereos?count=true Using conditions: GET /api/stereos?count=true&conditions={\"age\":{\"$gt\":2}} Distinct Same as mongoose distinct : GET /api/restaurants?distinct=category Detailed version of this document. POST this option is to create documents. Basic: POST /api/birds body: { \"name\": \"poli\", \"age\":3 } No mistery here. If the document is created you will receive a 200 status with the document. PUT Updating documents. Basic: This request will update a particular document. PUT /api/books/:id Body: { title: 'new title', tags: ['new tags'] } Update with conditions: Also you can update documents using a condition filter as a query param. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: ['new tags'] } This will update all documents that satisfy the conditions filter. The $pull and $push param: Append or remove an element from an array. $push: PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: {$push:['new tags']} } This will add the new tag to the previous list of tags. $pull: if you want to remove an element from an array you can use the $pull param. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: {$pull:['asd']} } This will remove the asd tag from the existing list. DELETE DANGER HERE It's possible to delete a document using a request DELETE with the id as a parameter. DELETE /api/books/5c5303574ffead2c606d773b Response: status 200 & deleted document. Personally i recommend use decorators to validate all delete request.","title":"Usage, methods & parameters"},{"location":"rest-api/#usage-methods-parameters","text":"","title":"Usage, methods &amp; parameters"},{"location":"rest-api/#get","text":"get list of resources or a particular resource using filter or ids.","title":"GET"},{"location":"rest-api/#basic-request","text":"Basic GET /api/books Response: [ { \"id\":\"5d234073a00ebf1921a9225a\", \"title\":\"Example\", \"createdAt\" : ISODate(\"2019-07-08T13:09:07.346Z\"), \"updatedAt\" : ISODate(\"2019-07-08T18:26:01.800Z\"), }, { \"id\":\"5d234073a00ebf1921a9225b\", \"title\":\"Example 2\", \"createdAt\" : ISODate(\"2019-07-08T13:02:07.346Z\"), \"updatedAt\" : ISODate(\"2019-07-08T18:28:01.800Z\"), }, ... ] By Id GET /api/books/5d234073a00ebf1921a9225a { \"id\":\"5d234073a00ebf1921a9225a\", \"title\":\"Example\", \"createdAt\" : ISODate(\"2019-07-08T13:09:07.346Z\"), \"updatedAt\" : ISODate(\"2019-07-08T18:26:01.800Z\"), }","title":"Basic request:"},{"location":"rest-api/#query-filtering","text":"","title":"Query filtering:"},{"location":"rest-api/#conditions","text":"Conditions paramer is like mongoose find parameter but you always should use the stringified version. Basic Example GET /api/books?conditions={ \"title\": \"Example1\" } Using mongoose $near GET /api/people?conditions={ \"location\": { \"$near\": [44, -97] } } Using mongoose $search GET /api/people?conditions={ \"$text\": { \"$search\": \"dog bites man\" } }","title":"Conditions"},{"location":"rest-api/#skip","text":"Same as mongoose skip GET /api/horses?skip=3 skip the first 3 documents.","title":"Skip"},{"location":"rest-api/#limit","text":"Same as mongoose limit . GET /api/horses?limit=3 get only 3 documents.","title":"Limit"},{"location":"rest-api/#sort","text":"Similar to mongoose sort . this example sort by name / decreasing age GET /api/cheeses?sort=name -age","title":"Sort"},{"location":"rest-api/#select","text":"Similar to mongoose select . It is a string space separated. Also you can use -[String] to not select some field. Basic Example GET /api/phones?select=name Negative select GET /api/phones?select=-_id -year this show all the document except _id & year .","title":"Select"},{"location":"rest-api/#populate","text":"Same as mongoose populate. Basic Example: GET /api/boats?populate=captain Using match GET /api/cities?populate={ \"path\": \"captain\", \"match\": { \"age\": \"44\" } } The select option of populated documents is disallowed.","title":"Populate"},{"location":"rest-api/#count","text":"Same as mongoose count . Basic: GET /api/stereos?count=true Using conditions: GET /api/stereos?count=true&conditions={\"age\":{\"$gt\":2}}","title":"Count"},{"location":"rest-api/#distinct","text":"Same as mongoose distinct : GET /api/restaurants?distinct=category Detailed version of this document.","title":"Distinct"},{"location":"rest-api/#post","text":"this option is to create documents. Basic: POST /api/birds body: { \"name\": \"poli\", \"age\":3 } No mistery here. If the document is created you will receive a 200 status with the document.","title":"POST"},{"location":"rest-api/#put","text":"Updating documents.","title":"PUT"},{"location":"rest-api/#basic","text":"This request will update a particular document. PUT /api/books/:id Body: { title: 'new title', tags: ['new tags'] }","title":"Basic:"},{"location":"rest-api/#update-with-conditions","text":"Also you can update documents using a condition filter as a query param. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: ['new tags'] } This will update all documents that satisfy the conditions filter.","title":"Update with conditions:"},{"location":"rest-api/#the-pull-and-push-param","text":"Append or remove an element from an array. $push: PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: {$push:['new tags']} } This will add the new tag to the previous list of tags. $pull: if you want to remove an element from an array you can use the $pull param. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: {$pull:['asd']} } This will remove the asd tag from the existing list.","title":"The $pull and $push param:"},{"location":"rest-api/#delete","text":"DANGER HERE It's possible to delete a document using a request DELETE with the id as a parameter. DELETE /api/books/5c5303574ffead2c606d773b Response: status 200 & deleted document. Personally i recommend use decorators to validate all delete request.","title":"DELETE"},{"location":"rest-api/detailed-documentation/","text":"Detailed documentation Query string parameters Use query options from the client to make dynamic requests. Query options can be mixed as you see fit. conditions Set the Mongoose query's find or remove arguments. This can take full advtange of the MongoDB query syntax, using geolocation, regular expressions, or full text search. Special query operators are fine, and in fact geolocation, regular expression, and full text search capabilities are available to your API clients by default! GET /api/people?conditions={ \"location\": { \"$near\": [44, -97] } } GET /api/people?conditions={ \"$text\": { \"$search\": \"dog bites man\" } } GET /api/cats?sort=-name&limit=1&conditions={ \"features\": \"stripes\" } DELETE /api/people?conditions={ \"name\": { \"$regex\": \"^Bob W\", \"$options\": \"i\" } } skip Skip sending the first n matched documents in the response. Useful for paging. GET /api/horses?skip=3 limit Limit the response document count to n at maximum. GET /api/horses?limit=3 If both limit and skip are used on a request, the response Link header will be set with extra relations that give URLs for paging. sort Sort response documents by the given criteria. Here's how you'd sort the collection by name in ascending order, then by age in descending order. GET /api/cheeses?sort=name -age select Set which fields should be selected for response documents. GET /api/phones?select=-_id -year It is not permitted to use the select query option to select deselected paths. This is to allow a mechanism for hiding fields from client software. You can deselect paths in the Mongoose schema definition using select: false or in the controller by calling e.g. controller.select('-foo') . Your server middleware will be able to select these fields as usual using query.select , while preventing the client from selecting the field. Note that mixing inluding and excluding fields causes an error. populate Set which fields should be populated for response documents. See the Mongoose population documentation for more information. The string or object syntax can be used: GET /api/boats?populate=captain GET /api/cities?populate={ \"path\": \"captain\", \"match\": { \"age\": \"44\" } } The select option of populate is disallowed. Only paths deselected at the model level will be deselected in populate queries. count May be set to true for GET requests to specify that a count should be returned instead of documents GET /api/stereos?count=true distinct Set to a path name to retrieve an array of distinct values. GET /api/restaurants?distinct=category this documentation is based on baucis wiki Requests Update using PUT to update documents there are two options using PUT request. PUT /api/:collection/:id PUT /api/:collection?conditions[example]=true and Body object it can be updated using the id as a parameter or by sending the conditions object. In both cases, only one document is updated Example: PUT /api/books?conditions={\"title\":\"El juguete rabioso\"} PUT /api/books/5c5303574ffead2c606d773b #Body: { author: 'Roberto Arlt' } Delete document it is possible to delete a document using a request DELETE with the id as a parameter DELETE /api/books/5c5303574ffead2c606d773b Update documents For make an update we use the PUT method Basic Put Request This request will update a particular document PUT /api/books/:id Body: { title: 'new title', tags: ['new tags'] } Update Using conditions Also you can update documents using a condition filter as a query param. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: ['new tags'] } This will update all documents that satisfy the conditions filter. The $pull and $push param You can these params for append or remove an element from an array. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: {$push:['new tags']} } this will add the new tag to the previous list of tags. if you want to remove an element from an array you can use the $pull param. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: {$pull:['asd']} } this will remove the asd tag from the existing list.","title":"Detailed documentation"},{"location":"rest-api/detailed-documentation/#detailed-documentation","text":"","title":"Detailed documentation"},{"location":"rest-api/detailed-documentation/#query-string-parameters","text":"Use query options from the client to make dynamic requests. Query options can be mixed as you see fit.","title":"Query string parameters"},{"location":"rest-api/detailed-documentation/#conditions","text":"Set the Mongoose query's find or remove arguments. This can take full advtange of the MongoDB query syntax, using geolocation, regular expressions, or full text search. Special query operators are fine, and in fact geolocation, regular expression, and full text search capabilities are available to your API clients by default! GET /api/people?conditions={ \"location\": { \"$near\": [44, -97] } } GET /api/people?conditions={ \"$text\": { \"$search\": \"dog bites man\" } } GET /api/cats?sort=-name&limit=1&conditions={ \"features\": \"stripes\" } DELETE /api/people?conditions={ \"name\": { \"$regex\": \"^Bob W\", \"$options\": \"i\" } }","title":"conditions"},{"location":"rest-api/detailed-documentation/#skip","text":"Skip sending the first n matched documents in the response. Useful for paging. GET /api/horses?skip=3","title":"skip"},{"location":"rest-api/detailed-documentation/#limit","text":"Limit the response document count to n at maximum. GET /api/horses?limit=3 If both limit and skip are used on a request, the response Link header will be set with extra relations that give URLs for paging.","title":"limit"},{"location":"rest-api/detailed-documentation/#sort","text":"Sort response documents by the given criteria. Here's how you'd sort the collection by name in ascending order, then by age in descending order. GET /api/cheeses?sort=name -age","title":"sort"},{"location":"rest-api/detailed-documentation/#select","text":"Set which fields should be selected for response documents. GET /api/phones?select=-_id -year It is not permitted to use the select query option to select deselected paths. This is to allow a mechanism for hiding fields from client software. You can deselect paths in the Mongoose schema definition using select: false or in the controller by calling e.g. controller.select('-foo') . Your server middleware will be able to select these fields as usual using query.select , while preventing the client from selecting the field. Note that mixing inluding and excluding fields causes an error.","title":"select"},{"location":"rest-api/detailed-documentation/#populate","text":"Set which fields should be populated for response documents. See the Mongoose population documentation for more information. The string or object syntax can be used: GET /api/boats?populate=captain GET /api/cities?populate={ \"path\": \"captain\", \"match\": { \"age\": \"44\" } } The select option of populate is disallowed. Only paths deselected at the model level will be deselected in populate queries.","title":"populate"},{"location":"rest-api/detailed-documentation/#count","text":"May be set to true for GET requests to specify that a count should be returned instead of documents GET /api/stereos?count=true","title":"count"},{"location":"rest-api/detailed-documentation/#distinct","text":"Set to a path name to retrieve an array of distinct values. GET /api/restaurants?distinct=category this documentation is based on baucis wiki","title":"distinct"},{"location":"rest-api/detailed-documentation/#requests","text":"","title":"Requests"},{"location":"rest-api/detailed-documentation/#update-using-put","text":"to update documents there are two options using PUT request. PUT /api/:collection/:id PUT /api/:collection?conditions[example]=true and Body object it can be updated using the id as a parameter or by sending the conditions object. In both cases, only one document is updated","title":"Update using PUT"},{"location":"rest-api/detailed-documentation/#example","text":"PUT /api/books?conditions={\"title\":\"El juguete rabioso\"} PUT /api/books/5c5303574ffead2c606d773b #Body: { author: 'Roberto Arlt' }","title":"Example:"},{"location":"rest-api/detailed-documentation/#delete-document","text":"it is possible to delete a document using a request DELETE with the id as a parameter DELETE /api/books/5c5303574ffead2c606d773b","title":"Delete document"},{"location":"rest-api/detailed-documentation/#update-documents","text":"For make an update we use the PUT method","title":"Update documents"},{"location":"rest-api/detailed-documentation/#basic-put-request","text":"This request will update a particular document PUT /api/books/:id Body: { title: 'new title', tags: ['new tags'] }","title":"Basic Put Request"},{"location":"rest-api/detailed-documentation/#update-using-conditions","text":"Also you can update documents using a condition filter as a query param. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: ['new tags'] } This will update all documents that satisfy the conditions filter.","title":"Update Using conditions"},{"location":"rest-api/detailed-documentation/#the-pull-and-push-param","text":"You can these params for append or remove an element from an array. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: {$push:['new tags']} } this will add the new tag to the previous list of tags. if you want to remove an element from an array you can use the $pull param. PUT /api/books/?conditions={\"tag\":\"asd\"} Body: { title: 'new title', tags: {$pull:['asd']} } this will remove the asd tag from the existing list.","title":"The $pull and $push param"},{"location":"rest-api/one-request/","text":"One request multiple query using share route. This feature is available since v0.2.0 now we have a new path /api/share/:shareCondition . Configuration: you can use multiple queries in only one request using the shareQueryEnabled configuration for the controllers that you want enabled. Also check the configuration page . Usage Details: :shareCondition is a stringify object with this format: { modelName:{ params } } the params object is like the tradicional params. params : { limit: ... select: ... count: ... skip: ... conditions: ... } now instead of query params is an object. you can check details here Format response: you can use two methods to controll/format the response. shareFormat : this should be a sync function to format in the same way as the map function but it receives the collection as a second parameter. beforeShareEnd : this a express middleware that run before send the response, here you can do any sync process that you want. The formated response is in the req.shareResponse object. Remember to run next() doing that you want. Examples API build: 'use strict'; const hiroki = require('../../index'); const models = require('./models'); const decorators = require('./decorators'); function buildHiroki() { Object.keys(models).forEach((modelName) => { const options = modelName === 'Draws' ? {fastUpdate: 'enabled'} : {shareQueryEnabled:true}; const controller = hiroki.rest(models[modelName], options); if (decorators.hasOwnProperty(modelName)) { decorators[modelName](controller); } }); hiroki.shareFormat = (doc, collection) => { if(collection === 'books') { doc.book = true; } return doc; }; hiroki.beforeShareEnd = (req, res, next) => { req.shareResponse.fakeCollection = [1]; next(); }; return hiroki.build(); } module.exports = buildHiroki; Example Request GET '/api/share/{\"books\":{},\"users\":{\"conditions\":{\"_id\":\"5c01997482c8985ad9a7eb5c\"}}}' Response { users: [ { role: [], books: [], _id: '5c01997482c8985ad9a7eb5b', name: 'test user', email: 'test@lts.com', __v: 0 } ], books: [ { tag: [Array], _id: '5cfa87a6615ab0eb6fed5cf6', title: 'first book', tagCount: 1, __v: 0 } ] }","title":"One request multiple query using **share** route."},{"location":"rest-api/one-request/#one-request-multiple-query-using-share-route","text":"This feature is available since v0.2.0 now we have a new path /api/share/:shareCondition .","title":"One request multiple query using share route."},{"location":"rest-api/one-request/#configuration","text":"you can use multiple queries in only one request using the shareQueryEnabled configuration for the controllers that you want enabled. Also check the configuration page .","title":"Configuration:"},{"location":"rest-api/one-request/#usage-details","text":":shareCondition is a stringify object with this format: { modelName:{ params } } the params object is like the tradicional params. params : { limit: ... select: ... count: ... skip: ... conditions: ... } now instead of query params is an object. you can check details here","title":"Usage Details:"},{"location":"rest-api/one-request/#format-response","text":"you can use two methods to controll/format the response. shareFormat : this should be a sync function to format in the same way as the map function but it receives the collection as a second parameter. beforeShareEnd : this a express middleware that run before send the response, here you can do any sync process that you want. The formated response is in the req.shareResponse object. Remember to run next() doing that you want.","title":"Format response:"},{"location":"rest-api/one-request/#examples","text":"","title":"Examples"},{"location":"rest-api/one-request/#api-build","text":"'use strict'; const hiroki = require('../../index'); const models = require('./models'); const decorators = require('./decorators'); function buildHiroki() { Object.keys(models).forEach((modelName) => { const options = modelName === 'Draws' ? {fastUpdate: 'enabled'} : {shareQueryEnabled:true}; const controller = hiroki.rest(models[modelName], options); if (decorators.hasOwnProperty(modelName)) { decorators[modelName](controller); } }); hiroki.shareFormat = (doc, collection) => { if(collection === 'books') { doc.book = true; } return doc; }; hiroki.beforeShareEnd = (req, res, next) => { req.shareResponse.fakeCollection = [1]; next(); }; return hiroki.build(); } module.exports = buildHiroki;","title":"API build:"},{"location":"rest-api/one-request/#example-request","text":"GET '/api/share/{\"books\":{},\"users\":{\"conditions\":{\"_id\":\"5c01997482c8985ad9a7eb5c\"}}}'","title":"Example Request"},{"location":"rest-api/one-request/#response","text":"{ users: [ { role: [], books: [], _id: '5c01997482c8985ad9a7eb5b', name: 'test user', email: 'test@lts.com', __v: 0 } ], books: [ { tag: [Array], _id: '5cfa87a6615ab0eb6fed5cf6', title: 'first book', tagCount: 1, __v: 0 } ] }","title":"Response"}]}