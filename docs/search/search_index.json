{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hiroki build REST APIs faster than ever using the open source tools and standards you and your team already know. hiroki is an open source tool inspired by baucis . hiroki is fully compatible with mongoose 4 and 5. hiroki is written in ES6 standards. Getting Started To install: npm install --save hiroki Create simple rest api: ... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); hiroki.rest('Users');//enable GET,PUT,POST DELETE methods app.use('/api', hiroki.build()); app.listen(8012); Changelog v0.2.2 Params $push and $pull working for PUT method. For doing this a custom Assign method was added to hiroki, because of that we made a benchmark test to measure this performance impact. Check it Here . v0.2.0 Share Query path added. check the docs . v0.1.3 MongooseConnector added, dependencies update no breaking changes. In future releases, new connectors would be added. v0.1.2 Bugfix decorator for put route with :id as parameter v0.1.1: Bugfix count with conditions error. v0.1.0: PUT request fire pre save hook in Mongoose Schema. PUT update by condition only update one document. findOneAndUpdate method removed from PUT request. v0.0.9: Add support for new conditions format. ej: GET /api/users?conditions[active]=true v0.0.8: fix general request function affect all routes. This type of decorators affected all the routes. ... controller.request((req,res,next) = { res.status(401).json({}); }) now it only affects the route of that collection Sponsors:","title":"Hiroki"},{"location":"#hiroki","text":"build REST APIs faster than ever using the open source tools and standards you and your team already know. hiroki is an open source tool inspired by baucis . hiroki is fully compatible with mongoose 4 and 5. hiroki is written in ES6 standards.","title":"Hiroki"},{"location":"#getting-started","text":"To install: npm install --save hiroki Create simple rest api: ... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); hiroki.rest('Users');//enable GET,PUT,POST DELETE methods app.use('/api', hiroki.build()); app.listen(8012);","title":"Getting Started"},{"location":"#changelog","text":"v0.2.2 Params $push and $pull working for PUT method. For doing this a custom Assign method was added to hiroki, because of that we made a benchmark test to measure this performance impact. Check it Here . v0.2.0 Share Query path added. check the docs . v0.1.3 MongooseConnector added, dependencies update no breaking changes. In future releases, new connectors would be added. v0.1.2 Bugfix decorator for put route with :id as parameter v0.1.1: Bugfix count with conditions error. v0.1.0: PUT request fire pre save hook in Mongoose Schema. PUT update by condition only update one document. findOneAndUpdate method removed from PUT request. v0.0.9: Add support for new conditions format. ej: GET /api/users?conditions[active]=true v0.0.8: fix general request function affect all routes. This type of decorators affected all the routes. ... controller.request((req,res,next) = { res.status(401).json({}); }) now it only affects the route of that collection","title":"Changelog"},{"location":"#sponsors","text":"","title":"Sponsors:"},{"location":"basic-tutorial/rest-api/","text":"First REST api with hiroki In this tutorial we are going to build our first rest api with hiroki. Some things in this tutorial aren't the best practice but this is for keep the example simple. Setup First we must create a project folder. mkdir hello-hiroki cd hello-hiroki Now we have to create a packege.json file. npm init -y Install dependencies. npm i --save express mongoose body-parser hiroki Project folders Create a model folder. mkdir models in this folder we have to create our models. Create the first model create a model file (models/book.js) in models folder. models/book.js const mongoose = require('mongoose'); const Book = new mongoose.Schema({ title: String, description: String }); module.exports = mongoose.model('Book', Book); Create a index file for models. models/index.js const Book = require('./book'); module.exports = { Book } The server file Create a file app.js . step by step: Import dependencies: const express = require('express'); const mongoose = require('mongoose'); const models = require('./models'); const bodyParser = require('body-parser'); const hiroki = require('hiroki'); Create the express app and use body-parser. const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); Connect to mongo: mongoose.connect('mongodb://localhost:27017/test') .then(()= { console.log('connection succes!'); }) Build the rest api: Object.keys(models).forEach((model)= { hiroki.rest(model); }) app.use(hiroki.build()); Handle errors: app.use(function(req, res, next) { let err = new Error('Not Found'); err.status = 404; next(err); }); app.use(function(error, req, res, next) { console.error('handleError: ', error); return res.status(error.status || 500).json({ status: error.status, error: error.message, stack: error.stack }); }); The end: add the app listen app.listen(3030); console.log('server listening on port 3030...'); File app.js: This is the complete file. const express = require('express'); const mongoose = require('mongoose'); const models = require('./models'); const bodyParser = require('body-parser'); const hiroki = require('hiroki'); const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); mongoose.connect('mongodb://localhost:27017/test') .then(()= { console.log('connection succes!'); }) Object.keys(models).forEach((model)= { hiroki.rest(model); }) app.use(hiroki.build()); app.use(function(req, res, next) { let err = new Error('Not Found'); err.status = 404; next(err); }); app.use(function(error, req, res, next) { console.error('handleError: ', error); return res.status(error.status || 500).json({ status: error.status, error: error.message, stack: error.stack }); }); app.listen(3030); console.log('server listening on port 3030...'); Start application node app.js now you can open 'http://localhost:3030/api/books'. have fun! Remember: GET: get documents. POST: create one document. PUT: update one document. DELETE: remove one document. Source code: HERE","title":"First REST api with hiroki"},{"location":"basic-tutorial/rest-api/#first-rest-api-with-hiroki","text":"In this tutorial we are going to build our first rest api with hiroki. Some things in this tutorial aren't the best practice but this is for keep the example simple.","title":"First REST api with hiroki"},{"location":"basic-tutorial/rest-api/#setup","text":"First we must create a project folder. mkdir hello-hiroki cd hello-hiroki Now we have to create a packege.json file. npm init -y Install dependencies. npm i --save express mongoose body-parser hiroki","title":"Setup"},{"location":"basic-tutorial/rest-api/#project-folders","text":"Create a model folder. mkdir models in this folder we have to create our models.","title":"Project folders"},{"location":"basic-tutorial/rest-api/#create-the-first-model","text":"create a model file (models/book.js) in models folder. models/book.js const mongoose = require('mongoose'); const Book = new mongoose.Schema({ title: String, description: String }); module.exports = mongoose.model('Book', Book); Create a index file for models. models/index.js const Book = require('./book'); module.exports = { Book }","title":"Create the first model"},{"location":"basic-tutorial/rest-api/#the-server-file","text":"Create a file app.js .","title":"The server file"},{"location":"basic-tutorial/rest-api/#step-by-step","text":"Import dependencies: const express = require('express'); const mongoose = require('mongoose'); const models = require('./models'); const bodyParser = require('body-parser'); const hiroki = require('hiroki'); Create the express app and use body-parser. const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); Connect to mongo: mongoose.connect('mongodb://localhost:27017/test') .then(()= { console.log('connection succes!'); }) Build the rest api: Object.keys(models).forEach((model)= { hiroki.rest(model); }) app.use(hiroki.build()); Handle errors: app.use(function(req, res, next) { let err = new Error('Not Found'); err.status = 404; next(err); }); app.use(function(error, req, res, next) { console.error('handleError: ', error); return res.status(error.status || 500).json({ status: error.status, error: error.message, stack: error.stack }); }); The end: add the app listen app.listen(3030); console.log('server listening on port 3030...');","title":"step by step:"},{"location":"basic-tutorial/rest-api/#file-appjs","text":"This is the complete file. const express = require('express'); const mongoose = require('mongoose'); const models = require('./models'); const bodyParser = require('body-parser'); const hiroki = require('hiroki'); const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); mongoose.connect('mongodb://localhost:27017/test') .then(()= { console.log('connection succes!'); }) Object.keys(models).forEach((model)= { hiroki.rest(model); }) app.use(hiroki.build()); app.use(function(req, res, next) { let err = new Error('Not Found'); err.status = 404; next(err); }); app.use(function(error, req, res, next) { console.error('handleError: ', error); return res.status(error.status || 500).json({ status: error.status, error: error.message, stack: error.stack }); }); app.listen(3030); console.log('server listening on port 3030...');","title":"File app.js:"},{"location":"basic-tutorial/rest-api/#start-application","text":"node app.js now you can open 'http://localhost:3030/api/books'. have fun!","title":"Start application"},{"location":"basic-tutorial/rest-api/#remember","text":"GET: get documents. POST: create one document. PUT: update one document. DELETE: remove one document.","title":"Remember:"},{"location":"basic-tutorial/rest-api/#source-code","text":"HERE","title":"Source code:"},{"location":"extending-hiroki/decorators/","text":"Extending Hiroki you can easly extend hiroji using a simple express middleware. Using decorators hiroki.rest return a Controller object. see details of controller methods here . Example ... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); const controller = hiroki.rest('Users'); controller.request('get', (req,res,next) = { req.query.limit = 3; //override query params limit next(); }) app.use('/api', hiroki.build()); app.listen(8012);","title":"Extending Hiroki"},{"location":"extending-hiroki/decorators/#extending-hiroki","text":"you can easly extend hiroji using a simple express middleware.","title":"Extending Hiroki"},{"location":"extending-hiroki/decorators/#using-decorators","text":"hiroki.rest return a Controller object. see details of controller methods here .","title":"Using decorators"},{"location":"extending-hiroki/decorators/#example","text":"... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); const controller = hiroki.rest('Users'); controller.request('get', (req,res,next) = { req.query.limit = 3; //override query params limit next(); }) app.use('/api', hiroki.build()); app.listen(8012);","title":"Example"},{"location":"extending-hiroki/overview/","text":"Controller Object hiroki.rest return a Controller object. this object build routes for a particular mongoose model. const controller = hiroki.rest(model); Structure Methods request: extend functionality using middlewares before hiroki native middlewares. build: build specific route. (hiroki.build run build for each controller) Statics methods Controller.getRouter: return the current express router. Set properties disabledMethods: String with disabled routes. Ej: disabledMethods = \"get post\"'' outgoing: format middleware before response. beforeEnd: after format route. Details Usage detail of use for some useful functions Request controler.request(methods, middleware) enable to add middleware before hiroki routes. methods(String): methods separated by spaces. get post put delete if you wish you can ignore the methods parameter and the middleware will apply to all methods. Example: ... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); const controller = hiroki.rest('Users'); controller.request((req, res, next) = { //do something //... next(); }); controller.request('delete post put', (req,res,next) = { req.status(401).json({error:'unauthorized'}); }) app.use('/api', hiroki.build()); app.listen(8012); Disabled methods DisabledMethods alows you to disable some hiroki methods. request with this methods return 404 status. Example: ... const controller = hiroki.rest('Users'); controller.disabledMethods = 'delete put'; app.use('/api', hiroki.build()); app.listen(8012); Outgoing Outgoing allows you to add a formatting function before the output. The function receives each document and is executed once for each document. ... const controller = hiroki.rest('Users'); controller.outGoing = function(doc) { doc.outName = doc.name.toUpperCase() return doc }; app.use('/api', hiroki.build()); app.listen(8012); BeforeEnd beforeEnd allows you to add a middleware that is executed before returning the server response and after formatting all the documents within this function you can manipulate the object req.rest req.rest can contain up to 3 parameters: count, response (formatted documents) and status (http status) req.rest structure { count : Number , response : Docs , status : Number } beforeEnd usage controller.beforeEnd = function(req,res,next){ doSomething(); next(); //hiroki make the response }","title":"Controller Object"},{"location":"extending-hiroki/overview/#controller-object","text":"hiroki.rest return a Controller object. this object build routes for a particular mongoose model. const controller = hiroki.rest(model);","title":"Controller Object"},{"location":"extending-hiroki/overview/#structure","text":"","title":"Structure"},{"location":"extending-hiroki/overview/#methods","text":"request: extend functionality using middlewares before hiroki native middlewares. build: build specific route. (hiroki.build run build for each controller)","title":"Methods"},{"location":"extending-hiroki/overview/#statics-methods","text":"Controller.getRouter: return the current express router.","title":"Statics methods"},{"location":"extending-hiroki/overview/#set-properties","text":"disabledMethods: String with disabled routes. Ej: disabledMethods = \"get post\"'' outgoing: format middleware before response. beforeEnd: after format route.","title":"Set properties"},{"location":"extending-hiroki/overview/#details-usage","text":"detail of use for some useful functions","title":"Details Usage"},{"location":"extending-hiroki/overview/#request","text":"controler.request(methods, middleware) enable to add middleware before hiroki routes. methods(String): methods separated by spaces. get post put delete if you wish you can ignore the methods parameter and the middleware will apply to all methods. Example: ... const app = express(); const UsersSchema = new mongoose.Schema({name}); mongoose.model('Users', UsersSchema); const controller = hiroki.rest('Users'); controller.request((req, res, next) = { //do something //... next(); }); controller.request('delete post put', (req,res,next) = { req.status(401).json({error:'unauthorized'}); }) app.use('/api', hiroki.build()); app.listen(8012);","title":"Request"},{"location":"extending-hiroki/overview/#disabled-methods","text":"DisabledMethods alows you to disable some hiroki methods. request with this methods return 404 status. Example: ... const controller = hiroki.rest('Users'); controller.disabledMethods = 'delete put'; app.use('/api', hiroki.build()); app.listen(8012);","title":"Disabled methods"},{"location":"extending-hiroki/overview/#outgoing","text":"Outgoing allows you to add a formatting function before the output. The function receives each document and is executed once for each document. ... const controller = hiroki.rest('Users'); controller.outGoing = function(doc) { doc.outName = doc.name.toUpperCase() return doc }; app.use('/api', hiroki.build()); app.listen(8012);","title":"Outgoing"},{"location":"extending-hiroki/overview/#beforeend","text":"beforeEnd allows you to add a middleware that is executed before returning the server response and after formatting all the documents within this function you can manipulate the object req.rest req.rest can contain up to 3 parameters: count, response (formatted documents) and status (http status)","title":"BeforeEnd"},{"location":"extending-hiroki/overview/#reqrest-structure","text":"{ count : Number , response : Docs , status : Number }","title":"req.rest structure"},{"location":"extending-hiroki/overview/#beforeend-usage","text":"controller.beforeEnd = function(req,res,next){ doSomething(); next(); //hiroki make the response }","title":"beforeEnd usage"},{"location":"rest-api/rest-api-delete/","text":"Requests Update using PUT to update documents there are two options using PUT request. PUT /api/:collection/:id PUT /api/:collection?conditions[example]=true and Body object it can be updated using the id as a parameter or by sending the conditions object. In both cases, only one document is updated Example: PUT /api/books?conditions={ title : El juguete rabioso } PUT /api/books/5c5303574ffead2c606d773b #Body: { author: 'Roberto Arlt' } Delete document it is possible to delete a document using a request DELETE with the id as a parameter DELETE /api/books/5c5303574ffead2c606d773b","title":"Requests"},{"location":"rest-api/rest-api-delete/#requests","text":"","title":"Requests"},{"location":"rest-api/rest-api-delete/#update-using-put","text":"to update documents there are two options using PUT request. PUT /api/:collection/:id PUT /api/:collection?conditions[example]=true and Body object it can be updated using the id as a parameter or by sending the conditions object. In both cases, only one document is updated","title":"Update using PUT"},{"location":"rest-api/rest-api-delete/#example","text":"PUT /api/books?conditions={ title : El juguete rabioso } PUT /api/books/5c5303574ffead2c606d773b #Body: { author: 'Roberto Arlt' }","title":"Example:"},{"location":"rest-api/rest-api-delete/#delete-document","text":"it is possible to delete a document using a request DELETE with the id as a parameter DELETE /api/books/5c5303574ffead2c606d773b","title":"Delete document"},{"location":"rest-api/rest-api/","text":"Query string parameters Use query options from the client to make dynamic requests. Query options can be mixed as you see fit. conditions Set the Mongoose query's find or remove arguments. This can take full advtange of the MongoDB query syntax, using geolocation, regular expressions, or full text search. Special query operators are fine, and in fact geolocation, regular expression, and full text search capabilities are available to your API clients by default! GET /api/people?conditions={ \"location\": { \"$near\": [44, -97] } } GET /api/people?conditions={ \"$text\": { \"$search\": \"dog bites man\" } } GET /api/cats?sort=-name limit=1 conditions={ \"features\": \"stripes\" } DELETE /api/people?conditions={ \"name\": { \"$regex\": \"^Bob W\", \"$options\": \"i\" } } skip Skip sending the first n matched documents in the response. Useful for paging. GET /api/horses?skip=3 limit Limit the response document count to n at maximum. GET /api/horses?limit=3 If both limit and skip are used on a request, the response Link header will be set with extra relations that give URLs for paging. sort Sort response documents by the given criteria. Here's how you'd sort the collection by name in ascending order, then by age in descending order. GET /api/cheeses?sort=name -age select Set which fields should be selected for response documents. GET /api/phones?select=-_id -year It is not permitted to use the select query option to select deselected paths. This is to allow a mechanism for hiding fields from client software. You can deselect paths in the Mongoose schema definition using select: false or in the controller by calling e.g. controller.select('-foo') . Your server middleware will be able to select these fields as usual using query.select , while preventing the client from selecting the field. Note that mixing inluding and excluding fields causes an error. populate Set which fields should be populated for response documents. See the Mongoose population documentation for more information. The string or object syntax can be used: GET /api/boats?populate=captain GET /api/cities?populate={ \"path\": \"captain\", \"match\": { \"age\": \"44\" } } The select option of populate is disallowed. Only paths deselected at the model level will be deselected in populate queries. count May be set to true for GET requests to specify that a count should be returned instead of documents GET /api/stereos?count=true distinct Set to a path name to retrieve an array of distinct values. GET /api/restaurants?distinct=category this documentation is based on baucis wiki","title":"Query string parameters"},{"location":"rest-api/rest-api/#query-string-parameters","text":"Use query options from the client to make dynamic requests. Query options can be mixed as you see fit.","title":"Query string parameters"},{"location":"rest-api/rest-api/#conditions","text":"Set the Mongoose query's find or remove arguments. This can take full advtange of the MongoDB query syntax, using geolocation, regular expressions, or full text search. Special query operators are fine, and in fact geolocation, regular expression, and full text search capabilities are available to your API clients by default! GET /api/people?conditions={ \"location\": { \"$near\": [44, -97] } } GET /api/people?conditions={ \"$text\": { \"$search\": \"dog bites man\" } } GET /api/cats?sort=-name limit=1 conditions={ \"features\": \"stripes\" } DELETE /api/people?conditions={ \"name\": { \"$regex\": \"^Bob W\", \"$options\": \"i\" } }","title":"conditions"},{"location":"rest-api/rest-api/#skip","text":"Skip sending the first n matched documents in the response. Useful for paging. GET /api/horses?skip=3","title":"skip"},{"location":"rest-api/rest-api/#limit","text":"Limit the response document count to n at maximum. GET /api/horses?limit=3 If both limit and skip are used on a request, the response Link header will be set with extra relations that give URLs for paging.","title":"limit"},{"location":"rest-api/rest-api/#sort","text":"Sort response documents by the given criteria. Here's how you'd sort the collection by name in ascending order, then by age in descending order. GET /api/cheeses?sort=name -age","title":"sort"},{"location":"rest-api/rest-api/#select","text":"Set which fields should be selected for response documents. GET /api/phones?select=-_id -year It is not permitted to use the select query option to select deselected paths. This is to allow a mechanism for hiding fields from client software. You can deselect paths in the Mongoose schema definition using select: false or in the controller by calling e.g. controller.select('-foo') . Your server middleware will be able to select these fields as usual using query.select , while preventing the client from selecting the field. Note that mixing inluding and excluding fields causes an error.","title":"select"},{"location":"rest-api/rest-api/#populate","text":"Set which fields should be populated for response documents. See the Mongoose population documentation for more information. The string or object syntax can be used: GET /api/boats?populate=captain GET /api/cities?populate={ \"path\": \"captain\", \"match\": { \"age\": \"44\" } } The select option of populate is disallowed. Only paths deselected at the model level will be deselected in populate queries.","title":"populate"},{"location":"rest-api/rest-api/#count","text":"May be set to true for GET requests to specify that a count should be returned instead of documents GET /api/stereos?count=true","title":"count"},{"location":"rest-api/rest-api/#distinct","text":"Set to a path name to retrieve an array of distinct values. GET /api/restaurants?distinct=category this documentation is based on baucis wiki","title":"distinct"},{"location":"rest-api/share-query/","text":"Share query This feature is available since v0.2.0 now we have a new path /api/share/:shareCondition . :shareCondition is a stringify object with this format: { modelName:{ params } } the params object is like the tradicional params. params : { limit: ... select: ... count: ... skip: ... conditions: ... } now instead of query params is an object. you can check details here Example Share query GET '/api/share/{\"books\":{},\"users\":{\"conditions\":{\"_id\":\"5c01997482c8985ad9a7eb5c\"}}}' Response { users: [ { role: [], books: [], _id: '5c01997482c8985ad9a7eb5b', name: 'test user', email: 'test@lts.com', __v: 0 } ], books: [ { tag: [Array], _id: '5cfa87a6615ab0eb6fed5cf6', title: 'first book', tagCount: 1, __v: 0 } ] }","title":"Share query"},{"location":"rest-api/share-query/#share-query","text":"This feature is available since v0.2.0 now we have a new path /api/share/:shareCondition . :shareCondition is a stringify object with this format: { modelName:{ params } } the params object is like the tradicional params. params : { limit: ... select: ... count: ... skip: ... conditions: ... } now instead of query params is an object. you can check details here","title":"Share query"},{"location":"rest-api/share-query/#example-share-query","text":"GET '/api/share/{\"books\":{},\"users\":{\"conditions\":{\"_id\":\"5c01997482c8985ad9a7eb5c\"}}}'","title":"Example Share query"},{"location":"rest-api/share-query/#response","text":"{ users: [ { role: [], books: [], _id: '5c01997482c8985ad9a7eb5b', name: 'test user', email: 'test@lts.com', __v: 0 } ], books: [ { tag: [Array], _id: '5cfa87a6615ab0eb6fed5cf6', title: 'first book', tagCount: 1, __v: 0 } ] }","title":"Response"},{"location":"rest-api/update-documents/","text":"Update documents For make an update we use the PUT method Basic Put Request This request will update a particular document PUT /api/books/:id Body: { title: 'new title', tags: ['new tags'] } Update Using conditions Also you can update documents using a condition filter as a query param. PUT /api/books/?conditions={ tag : asd } Body: { title: 'new title', tags: ['new tags'] } This will update all documents that satisfy the conditions filter. The $pull and $push param You can these params for append or remove an element from an array. PUT /api/books/?conditions={ tag : asd } Body: { title: 'new title', tags: {$push:['new tags']} } this will add the new tag to the previous list of tags. if you want to remove an element from an array you can use the $pull param. PUT /api/books/?conditions={ tag : asd } Body: { title: 'new title', tags: {$pull:['asd']} } this will remove the asd tag from the existing list.","title":"Update documents"},{"location":"rest-api/update-documents/#update-documents","text":"For make an update we use the PUT method","title":"Update documents"},{"location":"rest-api/update-documents/#basic-put-request","text":"This request will update a particular document PUT /api/books/:id Body: { title: 'new title', tags: ['new tags'] }","title":"Basic Put Request"},{"location":"rest-api/update-documents/#update-using-conditions","text":"Also you can update documents using a condition filter as a query param. PUT /api/books/?conditions={ tag : asd } Body: { title: 'new title', tags: ['new tags'] } This will update all documents that satisfy the conditions filter.","title":"Update Using conditions"},{"location":"rest-api/update-documents/#the-pull-and-push-param","text":"You can these params for append or remove an element from an array. PUT /api/books/?conditions={ tag : asd } Body: { title: 'new title', tags: {$push:['new tags']} } this will add the new tag to the previous list of tags. if you want to remove an element from an array you can use the $pull param. PUT /api/books/?conditions={ tag : asd } Body: { title: 'new title', tags: {$pull:['asd']} } this will remove the asd tag from the existing list.","title":"The $pull and $push param"}]}